# Data-Structure-Algorithm

This repository contains C++ implementations of various data structures and algorithms. The code is organized into directories based on the data structure or algorithm being implemented.
## Useful Patterns for DSA Interviews

The following patterns can be used to solve many problems related to data structures and algorithms in technical interviews.

- Sliding Window
- Islands (Matrix Traversal)
- Two Pointers
- Fast & Slow Pointers
- Merge Intervals
- Cyclic Sort
- In-place Reversal of a LinkedList
- Tree Breadth-First Search
- Tree Depth First Search
- Two Heaps
- Subsets
- Modified Binary Search
- Bitwise XOR
- Top ‘K’ Elements
- K-way Merge
- Topological Sort
- 0/1 Knapsack
- Fibonacci Numbers
- Palindromic Subsequence
- Longest Common Substring

## Tips for Solving Coding Questions

Here are some tips that can help you solve coding questions efficiently:

- If the input array is sorted, consider using Binary Search, Two Pointers, or Binary Search for finding for certain range and want less than that range.
- If you want to find the next element, consider using a stack.
- If the input is a binary tree, consider using DFS (Preorder, Inorder, Postorder) or BFS (Level Order).
- If the input is a binary search tree, consider using Left < Cur < Right and Inorder Traversal.
- If the input is a matrix/graph, consider using DFS (Recursion, Stack) or BFS (Queue).
- To find the shortest/nearest path/distance in a tree/matrix/graph, consider using BFS (non-weighted) or Dijkstra (weighted).
- For string concatenation, consider using StringBuilder or String.join().
- If the input is a linked list, consider using a Dummy Node, Two Pointers, or Fast & Slow Pointers.
- If you need to compute the same input multiple times, consider using Memoization (DP).
- If recursion is banned, consider using a Stack.
- To compute permutations/combinations/subsets, consider using Backtracking.
- To find the top/least Kth element, consider using QuickSelect or Heap.
- For common strings, consider using Map or Trie.
- For sorting, consider using Quick Sort, Merge Sort, or built-in sorts.
- To find the smallest/largest/median in a stream, consider using Two Heaps.
- For maximum/minimum subarray/subset/options, consider using Dynamic Programming.
- For Map/Set, the time complexity is O(1) and space complexity is O(n).
- For Deque, you can replace Stack, Queue, and LinkedList.

## License

This project is licensed under the MIT License. Feel free to use the code for your personal or commercial projects. However, I cannot be held responsible for any issues or problems that arise from the use of this code.
